# 2025.5.13

初始化项目

# 2025.5.14

进行项目的前期工作。规范化。

抽象通用请求体。比如：删除数据请求， 分页查询请求。

抽象通用响应体。 编写BaseResponse类，封装响应体，包含：响应码， 数据， 消息， 描述。

构建全局异常处理器。

抽象通用业务异常类。

抽像通用错误响应码。

--------

# 第一阶段

完成用户管理以及图片管理模块。

* 阶段流程：
  1. 需求分析
  2. 方案设计
  3. 后端开发
  4. 前端开发

## 需求分析

1. 用户能够注册，登录，退出登录。
2. 用户能够修改个人信息
3. 用户具有管理员和普通用户这两个角色，不同角色具有不同权限。
4. 用户管理：仅管理员可用， 能够创建用户，修改用户，查询用户，搜索用户。
5. 获取当前登录用户

## 方案设计

* 库表设计

首先，用户表需要有 固定的五个字段（企业开发常见规范） ： id（用户标识）， editTime（用户编辑时间）, createTime（本条记录创建时间）, updateTime（本条记录更新时间，这个和editTime的区别是，即使是管理员直接修改数据库，这个时间也要更新）, isDelete（逻辑删除）。

然后是与用户体验相关的字段：用户昵称， 用户账号， 用户密码，用户头像，用户简介， 用户角色。

```sql
-- 用户表
create table if not exists user
(
    id           bigint auto_increment comment 'id' primary key,
    userAccount  varchar(256)                           not null comment '账号',
    userPassword varchar(512)                           not null comment '密码',
    userName     varchar(256)                           null comment '用户昵称',
    userAvatar   varchar(1024)                          null comment '用户头像',
    userProfile  varchar(512)                           null comment '用户简介',
    userRole     varchar(256) default 'user'            not null comment '用户角色：user/admin',
    editTime     datetime     default CURRENT_TIMESTAMP not null comment '编辑时间',
    createTime   datetime     default CURRENT_TIMESTAMP not null comment '创建时间',
    updateTime   datetime     default CURRENT_TIMESTAMP not null on update CURRENT_TIMESTAMP comment '更新时间',
    isDelete     tinyint      default 0                 not null comment '是否删除',
    UNIQUE KEY uk_userAccount (userAccount),
    INDEX idx_userName (userName)
    ) comment '用户' collate = utf8mb4_unicode_ci;
    
-- 用户账号添加了唯一索引， 用户昵称添加了普通索引，能够加速以名称为条件时的查询
```

* 流程设计

用户注册：

需要一个UserRegisterRequest请求封装类， 用于接收用户的输入参数，主要包含用户账户， 用户密码， 确认密码。

1. 接收到请用户注册请求封装类参数后，先校验其是否为空，若为空则抛出BusinessException异常。
2. 调用UserService服务，进行用户注册。
   1. 校验用户账户，用户密码是否符合要求。用户账户长度要在5-20之间，用户密码长度要在6-10之间，用户密码要和确认密码相同。
   2. 在userService服务中，先查询该用户账户是否存在，若不存在，则继续下一步；否则，抛出异常。
   3. 插入用户数据，返回插入结果。
3. 在Controller层，需要以BaseResponse<>的统一响应体形式返回结果给用户。

> **tip**:
>
> 由于后端使用Long类型来标识用户id，而前端接收时，会自动将id解析为number类型，number的是双精度浮点类型，其取值范围没有long类型大，所以，当我们的id由mybatis自己生成时，会导致long数值过大，前端解析时会出现精度溢出。
>
> 对于需要使用超大整数的场景，服务端一律使用String字符串类型返回，禁止使用Long类型。
>
> ```java
> package com.tlm.storecollab.config;
> 
> import com.fasterxml.jackson.databind.ObjectMapper;
> import com.fasterxml.jackson.databind.module.SimpleModule;
> import com.fasterxml.jackson.databind.ser.std.ToStringSerializer;
> import org.springframework.boot.jackson.JsonComponent;
> import org.springframework.context.annotation.Bean;
> import org.springframework.http.converter.json.Jackson2ObjectMapperBuilder;
> 
> /**
>  * Spring MVC Json 配置
>  */
> @JsonComponent
> public class JsonConfig {
> 
>     /**
>      * 添加 Long 转 json 精度丢失的配置
>      */
>     @Bean
>     public ObjectMapper jacksonObjectMapper(Jackson2ObjectMapperBuilder builder) {
>         ObjectMapper objectMapper = builder.createXmlMapper(false).build();
>         SimpleModule module = new SimpleModule();
>         module.addSerializer(Long.class, ToStringSerializer.instance);
>         module.addSerializer(Long.TYPE, ToStringSerializer.instance);
>         objectMapper.registerModule(module);
>         return objectMapper;
>     }
> }
> ```

用户登录：

需要一个UserLoginRequest请求封装类， 用于接收用户的输入参数，主要包含用户账户， 用户密码。使用Lombok注解为其生成get和set方法。

1. 接收到请用户登录请求封装类参数后，先校验其是否为空，若为空则抛出BusinessException异常。
2. 调用UserService服务，进行用户登录。
   1. 查询数据库，判断用户是否存在。不存在，抛出异常；若存在，继续下一步。
   2. 校验数据库中的密码和当前用户输入的密码加密后是否相等。如果相等，登录成功，将用户信息存入session中，否则，返回用户登录失败信息。
3. 返回用户登录结果信息。

获取当前登录用户：

首先需要要给LoginUserVO试图封装类，需要对User对象进行脱敏，屏蔽一些敏感字段。使用Lombok注解为其生成get，set方法，并添加serailversionId字段。

1. 从Session中获取当前用户的登录态。判断用户是否登录，如果获取不到，则表示用户未登录，抛出未登录异常。
2. 根据获取到的登录态，取出用户的id，从数据库中查询该用户，得到User对象。
3. 将得到的User对象通过BeanUtils工具进行属性复制到LoginUserVO类中并返回给Controller层。
4. 在Controller层返回LoginUserVO。

用户权限校验管理：**自定义注解进行权限校验**

利用AOP，对需要校验用户权限的方法，在执行方法前进行权限校验。

先定义好注解AuthCheck,里面包含一个mustRole属性，默认值为空，代表不需要任何权限。

再定义一个切面，在切面中再定义校验权限的切点。

所以，进行AOP切面编程，需要定义两个个东西：切面，切点。而由于使用注解来标识需要进行权限校验的方法，所以还需要定义注解。

1. 定义注解:

   ```java
   package com.tlm.storecollab.annotation;
   
   import java.lang.annotation.ElementType;
   import java.lang.annotation.Retention;
   import java.lang.annotation.RetentionPolicy;
   import java.lang.annotation.Target;
   
   @Target(ElementType.METHOD)
   @Retention(RetentionPolicy.RUNTIME)
   public @interface AuthCheck {
   
       String mustRole() default "";
   }
   
   ```

2. 定义切面和切点

   ```java
   @Aspect
   @Component
   public class AuthInterceptor {
   
       @Around("@annotation(authCheck)")
       public Object doIntercept(ProceedingJoinPoint joinPoint, AuthCheck authCheck) throws Throwable {
           String role = authCheck.mustRole();
           UserRoleEnum userRole = UserRoleEnum.getValueByValue(role);
   
           // 如果不需要权限，则直接执行
           if (userRole == null){
               return joinPoint.proceed();
           }
   
           // 获取当前用户所具有的权限
           RequestAttributes requestAttributes = RequestContextHolder.currentRequestAttributes();
           HttpServletRequest request = ((ServletRequestAttributes) requestAttributes).getRequest();
           Object attribute = request.getSession().getAttribute(UserConstant.USER_LOGIN_STATE);
           ThrowUtils.throwIf(ObjectUtil.isNull(attribute), ErrorCode.NOT_LOGIN);
           User loginUser = (User) attribute;
           String loginUserRole = loginUser.getUserRole();
           UserRoleEnum loginUserRoleEnum = UserRoleEnum.getValueByValue(loginUserRole);
   
           // 如果用户没有任何权限，则抛出异常
           ThrowUtils.throwIf(ObjectUtil.isNull(loginUserRoleEnum), ErrorCode.NO_AUTH);
   
           // 如果权限需要为 管理员 才能执行， 而用户又不是管理员
           if (UserRoleEnum.ADMIN.equals(userRole) && !UserRoleEnum.ADMIN.equals(loginUserRoleEnum)){
               throw new BusinessException(ErrorCode.NO_AUTH);
           }
   
           return joinPoint.proceed();
       }
   }
   
   ```

### 用户管理

用户管理功能具体可以拆分为:

* [管理员] 创建用户
* [管理员]根据id删除用户
* [管理员] 更新用户
* [管理员] 分页查询用户列表（需要脱敏）
* [管理员] 根据id获取用户（未脱敏）
* 根据id获取用户（脱敏）

对于mybatis分页查询：

于 `v3.5.9` 起，`PaginationInnerInterceptor` 已分离出来。如需使用，则需单独引入 `mybatis-plus-jsqlparser` 依赖 ， 具体请查看 [安装](https://baomidou.com/getting-started/install) 一章。



# 2025.05.15

# 图片模块

## 需求分析

管理员：

1. 上传和创建图片。（这里的理解：上传图片是指将图片存储到对象服务中，创建图片是指在数据库中创建一条图片记录）
2. 管理图片， 包括查询图片，修改图片，删除。
3. 能够根据图片属性进行分页查询。

普通用户：

1. 查看与搜索图片列表（主页）
2. 查看图片详情（详情页）
3. 图片下载

具体分析每个需求：

1. 上传和创建图片：仅管理员可用，支持选择本地图片上传，同时指定图片的相关信息，如名称，简介，标签，分类等。系统会自动解析图片的基础信息（如宽高和格式等），便于检索。
2. 图片管理：管理员可以对图库内的图片资源进行删除，修改，查询。
3. 查看搜索图片列表：用户在主页可以按关键字搜索图片，支持按分类、标签筛选条件分页查看图片列表。
4. 查看图片详情：点击某张图片后，可以进入详情页，查看图片的具体信息。
5. 图片下载：用户在详情页可以点击下载图片按钮，将图片保存到本地。

## 方案设计

* 库表设计 ： 主要是图片表， 需要有固定的五个字段(id, editTime, udpateTime, createTime, isDelete)。另外还有，url, name,introduction,category,tags,picSize,picWidth,picHeight,picScale,picFormat,userId。
  **哪些字段上需要加索引**：经常被作为条件查询，分组的字段，最好加上索引。

  ```java
  -- 图片表
  create table if not exists picture
  (
      id           bigint auto_increment comment 'id' primary key,
      url          varchar(512)                       not null comment '图片 url',
      name         varchar(128)                       not null comment '图片名称',
      introduction varchar(512)                       null comment '简介',
      category     varchar(64)                        null comment '分类',
      tags         varchar(512)                       null comment '标签（JSON 数组）',
      picSize      bigint                             null comment '图片体积',
      picWidth     int                                null comment '图片宽度',
      picHeight    int                                null comment '图片高度',
      picScale     double                             null comment '图片宽高比例',
      picFormat    varchar(32)                        null comment '图片格式',
      userId       bigint                             not null comment '创建用户 id',
      createTime   datetime default CURRENT_TIMESTAMP not null comment '创建时间',
      editTime     datetime default CURRENT_TIMESTAMP not null comment '编辑时间',
      updateTime   datetime default CURRENT_TIMESTAMP not null on update CURRENT_TIMESTAMP comment '更新时间',
      isDelete     tinyint  default 0                 not null comment '是否删除',
      INDEX idx_name (name),                 -- 提升基于图片名称的查询性能
      INDEX idx_introduction (introduction), -- 用于模糊搜索图片简介
      INDEX idx_category (category),         -- 提升基于分类的查询性能
      INDEX idx_tags (tags),                 -- 提升基于标签的查询性能
      INDEX idx_userId (userId)              -- 提升基于用户 ID 的查询性能
  ) comment '图片' collate = utf8mb4_unicode_ci;
  ```

* 如何存储图片？最简单的方法，将图片存储在本地服务器上。但是这种方法具有很多劣势。

  1. 不具扩展性。本地服务器存储容量有限，扩充麻烦。
  2. 不具安全性。本地服务器可能存在漏洞，恶意用户通过代码可能越权访问到隐私信息。
  3. 不具管理性。本地存储只能存储文件本身，没有提供额外的管理服务。腾讯云对象存储，还提供了数据万象等功能，能够分析数据。
  4. 不具可迁移性。当本地服务器需要迁移时，图片数据也需要跟着迁移，增加迁移成本。

* 存储图片业务流程。

  1. 传统方法，先上传再提交数据：用户在页面点击上传图片后，就会图片存储到云服务对象存储中并生成url，此时数据库中并不会生成一条记录。待用户填写其他信息并提交后，才会在数据库生成记录。
  2. 上传图片时就生成记录：用户上传图片时，直接在数据库生成记录。随后，用户填写其他信息，相当于更新数据库中已有的记录。

  方案1的特点是：流程简单。但是一旦用户上传文件后没有提交其他信息，文件就会残留在对象存储中，造成资源浪费。方案二的特点是：用户的操作和数据记录一致，能够溯源，还能够对用户上传图片做一些限制。

* 如何解析图片属性？
  根据需求，要获取的图片信息有：宽，高，宽高比，大小，格式，名称。
  主流获取图片属性的方式有两种：

  1. 后端直接处理图片。java库ImageIO,python库Pillow，OpenCV等。
  2. 通过第三方云存储服务或图像处理API直接提取图片元数据。

* 如何下载图片？
  下载图片有三种方式。
  
  1. 服务器从对象存储中下载图片到本地，用户从服务器上下载。
  2. 服务器从对象存储中获取流返回给前端，用户从流中读取数据。这种方法不需要服务器下载图片。
  3. 服务器生成临时密钥给前端，前端拿临时密钥去对象存储中下载。（企业常用，但繁琐）。



# 2025.05.18

# 用户传图

## 需求分析

* 支持用户自主上传图片和管理员审核图片功能
* 支持URL导入图片
* 支持批量抓取和创建图片

## 方案设计

* 管理员审核图片：

由于引入了审核，这意味着，图片具有了新的状态，需要为图片表添加新的字段用来表示它的审核状态。通常，对于审核类流程，需要添加四个字段:

> viewStatus: 当前审核状态
>
> viewTime: 审核时间
>
> viewer: 审核人id
>
> viewMessage: 审核理由（原因）

审核状态有： 待审核(reviewing), 审核通过(pass), 审核不通过(rejected)。

状态流转：业务流程中可能发生的状态转移

reviewing -> pass

reviewing -> rejected

pass -> rejected

rejected -> pass

* 用户自主上传图片： 这个功能可以复用前面管理员上传/创建图片的逻辑，只需要将权限开放给普通用户。

* 支持URL来导入图片

前面已经实现了用户上传图片的功能，其基本流程为：用户在页面点击上传文件后，从本地电脑中，选择要上传的图片。这个图片会传到服务器，并被服务器临时保存，然后经过图片校验后，传到对象存储服务中，服务器从对象存储服务的返回结果中，获取图片的相关属性信息。

现在需要支持用户传入图片URL导入图片。首先要面临的问题就是，服务器如何校验用户传入的URL是否合法以及这段URL所对应的网络内容是否合法。

校验用户输入的URL：1. 首先需要校验用户传入的URL是否符合URL的基本形式，比如https/http://开头，然后校验，这段URL背后所对应的内容是否合法。

### 获取URL所对应的网络资源属性

如何获取URL所对应的网络资源属性？需要使用到HTTP请求中的**Head**请求。

我们常见的HTTP请求有四种Get, Post, Put, Delete。除此以外，还有五种：Head, Options, Patch, trace, connect。

> 类似于 GET，但服务器只返回响应的头部，不返回实际数据。用于检查资源的元数据（例如，检查资源是否存在，查看响应的头部信息）。

通过head请求，获取网络资源的相关属性，进行校验，如果校验合法，可以使用hutool包中的下载网络文件包将该资源下载下来。

### 模板方法模式在文件上传场景的使用

分析用户上传图片和通过URL导入图片两个功能的流程，可以抽象出一个流程模板。

> 1. **用户给出输入源**(在上传图片场景，输入源是MultiPartFile，即表单文件传到服务器后的接收对象；在URL导入图片场景，输入源为URL路径)。
> 2. **校验输入源是否合法。**（校验合法主要需要获取到数据源的各项属性参数，在上传图片中，服务器可以从MultiPartFile中，直接获取；在URL导入图片场景中，则需要发送Head请求来获取，如果合法，再将URL网络资源下载到本地）
> 3. **将本地临时文件，通过第三方服务提供的SDK上传**到对象存储服务当中，获取返回结果（解析后的图片属性），将这些结果存储到数据库中。
> 4. **返回响应给用户**。

通过以上分析，可以发现，1， 2步骤，会根据不同的情况发生变化，而3,4步骤共用一套逻辑。所以可以使用**模板方法**，复用，3,4步骤，而在子类中重写1,2步骤。

### 模板方法模式和策略模式的区别

* 模板方法模式是对一套确定**流程**的抽象，这套流程中的某些步骤可能因为场景的不同有一些区别，但本质上是在做类似的事。

​		按照自己的理解：模板方法模式主要是抽象和复用。

* 策略模式是对同一个数据源采取不同的处理算法。不涉及到流程这一概念。

# 2025.05.20

# 批量抓取和创建图片

本功能只开放给管理员。

抓取图片首先需要确定**抓取源**。 

> 抓取源的选择：
>
> 图片素材网站？？？ 不建议。版权问题。
>
> 搜索引擎 √  数据来源广泛

确定抓取源后，需要找到抓取源提供图片信息的接口。在Bing搜索引擎中，通过下拉图片搜索页，会触发图片请求。找到那个请求，然后分析其接口URL，解析其响应结果（比如，如果返回结果为HTML页面，则可以解析其中img标签的src属性。

```java
https://cn.bing.com/images/async?q=%e4%b8%96%e7%95%8c%e6%97%85%e6%b8%b8%e8%83%9c%e5%9c%b0&first=105&count=35&cw=1177&ch=947&relp=35&apc=0&datsrc=I&layout=RowBased_Landscape&imgbf=DfCtqwgAAACQAQAAAAAAAAAAAAAFAAAAXWBtN%2bNfTNnF3AFZg0g4iUKAACHpcA1sClkoPRejQI66ALFw4hu3QdAAMJLInMBIiSgIgTwDSEckIQAAAAAAAA%3d%3d&mmasync=1&dgState=x*601_y*1348_h*185_c*2_i*105_r*25&IG=FBFD300F7EAF42999E63CBC6CEEB8CA4&SFX=4&iid=images.5615
```

这个接口返回的响应结果，在浏览器预览（浏览器F12调出开发者工具，点击“网络”，在对应的请求响应上选择“预览”），可以看到HTML的视觉效果。

上面的接口有很多查询参数，通过测试，可以找到一些必填参数。比如q标识查询关键字,count标识查询条数。

爬取网络数据，使用Json库。

* 方案设计

1. 管理员发起请求，指定查询关键字， 图片命名前缀，以及抓取条数。

2. 校验请求参数不为空

3. 查询关键字不能为空，图片命名前缀为空时，默认为关键字。抓取条数不能超过30条。
4. 利用Jsoup提取接口响应中所有的img标签的src属性，获取要下载的图片的url.
5. 复用根据url上传图片的代码。
6. 返回结果（成功抓取的图片条数)

# 图库优化一：查询优化

对于频繁被查询的数据，可以将其存储到缓存中，这样，就不会频繁访问数据库了。

### 哪些数据需要缓存

简单来说，“读多写少”的数据就需要缓存。具体来说:

1. 高频访问的数据。比如用户主页展示的固定数据，系统首页，热门内容推荐等。
2. 计算成本较高的数据。比如，复杂查询结果，大量数据的统计结果。
3. 允许短时间延迟的数据。比如，不需要实时更新的排行榜。

### 怎么将数据存到缓存中

* 分布式缓存： Redis

  分布式缓存是指将数据存储到**多台服务器**上，
  Redis是实现分布式缓存主流的方案。其有如下优点：

  * 高性能： 基于内存操作，访问速度极快。单节点Redis的读写QPS可达10w次每秒。
  * 数据结构丰富：支持存储字符串，列表，集合，z-set等。
  * 分布式支持：可以通过 Redis cluster构建高可用、高性能的分布式缓存，还提供哨兵集群机制提升可用性、提供分片集群机制提高可扩展性。

* 本地缓存: Caffiene
  本地缓存是指数据存储在本地机器的内存中。为什么不用java的map来直接作为本地缓存呢？缓存并不仅仅这是考虑存储，还要考虑淘汰策略（因为内存不是无限大），过期， 线程安全， 支持异步操作等问题。即使你知道如何实现，那也很麻烦。
  相较于分布式缓存， 本地缓存 速度更快，但是无法在多个服务器之间共享，而且不方便扩容。
  本地缓存的**应用场景:**

  * 数据访问量有限的小型数据
  * 不需要服务器之间共享数据的单机应用
  * 高频、低延迟的访问场景（如用户临时会话信息，短期热点数据)

💡 由于本地缓存不需要引入额外的中间件，成本更低。因此如果只是需要提高数据访问性能，优先考虑本地缓存而不是分布式缓存。

### 缓存设计

像Redis和Caffiene都是k/v存储系统。需要指定key 和 value。key是字符串类型， value可以是各种类型。但是一般，缓存对象，都会将该对象进行序列化后存储。

* key的设计
  key就是从缓存中获取value值的唯一标识，一般只需要保证唯一即可。但是，在分布式缓存场景下，由于Redis数据库成本较高，常常会出现多个项目共用一个Redis的情况，所以需要让key具有结构化的特征，以避免和其他项目发生冲突，导致缓存被覆盖。如果使用本地缓存，则key可以更加精简。
  常用的key结构如下: `项目ID: ModuleId: ${查询条件Key}`, 不同的团队可能有不同的规范，遵循团队规范即可。
  由于这里查询条件过多，所以可以使用md5对查询条件key进行压缩。
* value的序列化
  存储java对象，需要将该对象序列化。
  ①通常，会将其序列化为JSON字符串的形式进行存储，但这种方式会占用较多的存储空间，因为JSON格式会有许多“， 空格等分隔符。
  ②也可以将对象序列化为二进制数据，然后进行存储。
  在开发时，可以使用JSON序列化存储，这样存储到缓存中后，可以方便的识别存储的数据内容。上线时，可以将序列化策略变为二进制序列化，以追求更少的存储空间占用。
* 过期时间
  **必须设置缓存过期时间**。由于内存是有限且相对于磁盘较小的，所以缓存必须设置过期时间，避免占用过多的内存。根据实际业务场景和缓存空间的大小，数据一致性要求设置，合适即可。本系统中，由于查询条件较多，而且考虑到图片会持续更新，设置为5~60min即可。
  另外，需要考虑到，缓存的过期时间应该具有一定的随机性，即在一个时间范围内随机选取一个时间作为过期时间。如果过期时间都一样，那么可能存在某个时刻，大量缓存同时过期失效，这就会导致大量请求直接打到数据库上，导致数据库崩溃，这就是**缓存雪崩**。



# 多级缓存

联合使用本地缓存和分布式缓存可以获得较好的性能和不错的健壮性。

当用户发起查询请求时，先判断本地缓存中是否命中，如果命中，则直接返回数据；如果未命中，则进一步查询分布式缓存，判断是否命中，如果命中，则直接返回数据，并更新本地缓存；如果未命中，则查询数据库。最后返回数据库结果，并更新本地缓存和分布式缓存。

```mermaid
graph TD
    A[用户发起查询请求] --> B{本地缓存命中?}
    B -- 是 --> C[返回数据]
    B -- 否 --> D{分布式缓存命中?}
    D -- 是 --> E[返回数据并更新本地缓存]
    D -- 否 --> F[查询数据库]
    F --> G[返回数据库结果]
    G --> H[更新本地缓存和分布式缓存]
```

# 扩展
1、手动刷新缓存
在某些情况下，数据更新较为频繁，但自动刷新缓存机制可能存在延迟，可以通过手动刷新来解决。比如:
·提供一个刷新缓存的接口，仅管理员可调用。
·提供管理后台，支持管理员手动刷新指定缓存。
2、解决缓存常见问题
使用缓存时，一般要注意下面几个问题:
1)缓存击穿:某些 **热点数据** 在缓存过期后，大量请求直接打到数据库解决方案:设置热点数据的超长过期时间，或使用互斥锁(如 Redisson)控制缓存刷新。

2)缓存穿透:用户频繁请求不存在的数据，导致大量的请求直接触发数据库查询。解决方案:对无效查询结果也进行缓存(如设置空值缓存)，或者使用布隆过滤器。

3)缓存雪崩:大量缓存同时过期，导致请求打到数据库，系统崩溃。解决方案:设置不同缓存的过期时间，避免同时过期;或者使用多级缓存，减少对数据库的依赖。

《如何解决缓存中的常见问题》是一道经典的八股文，可以去刷题网站上学习。



# 2025-05-21

# 图库优化二： 上传优化

## 图片压缩

压缩图片意味着图片能够以更小的体积存储。进而可以降低带宽使用和流量消耗(因为后面用户访问的都是压缩后的图片)。大幅度降低成本的同时，提高图片的加载速度。

有哪些压缩图片的方法？

* 将图片格式转换为体积更小的格式，比如webp或其他现代格式。
* 对图片质量进行压缩
* 缩小图片尺寸

对于图像网站来说，最好不要影响图片的质量，因为用户不想看到自己存储的图片不清晰，因此使用第一种方式更为合适。

将图片压缩为什么格式？怎么对图片进行压缩？

> 图片的压缩格式：
>
> 1） webp: 由Google开发的现代图片格式，支持有损和无损压缩。相比传统格式：
>
> * 比PNG文件小约26%
> * 比JPEG文件小约25%~34%
> * 支持透明背景（Alpha通道）
> * 兼容性：大部分主流浏览器（如Chrome、Edge、FireFox等）均已支持WebP。
>
> 2） AVIF：基于AV1视频编码技术的图片格式，压缩率更高。
>
> * 比WebP的文件大小更小，画质更优。
> * 支持透明背景和高动态范围。（HDR）
>
> 虽然AVIF在性能上更优，但是兼容性不佳，为了确保用户能够正常打开文件，最好采用webp格式。

> 图片压缩方案：
>
> 1. 在本地利用图像处理库进行压缩
> 2. 利用第三方服务进行压缩。（https://cloud.tencent.com/document/product/460）

由于本项目的图片存储在第三方对象存储服务中，所以可以直接使用第三方服务商提供的接口来压缩图像。

[数据万象 图片处理机制介绍](https://cloud.tencent.com/document/product/460/18147)

## 拓展知识：文件秒传

文件秒传的本质是避免重复上传相同的文件。其实现方法为：对于第一次上传的文件，为其生成一个唯一标识（如MD5、SHA-256），当用户上传曾经上传过的文件时，会用当前正在上传的文件的唯一标识去数据库中比对，如果存在，则用户不需要重复传送文件，即可完成上传。

* 适用场景：在大型文件传输场景下非常重要，可以提高性能，节约带宽和存储资源。在网盘中常见，重复上传两个文件，第二次上传非常快。
* 在本项目中的使用限制
  * 本项目中，不适用文件秒传，因为一张图片大小有限，另外用户重复上传的可能性较小，秒传的优化效果有限。
  * 本项目使用腾讯云cos对象存储，只能通过唯一地址去取文件，无法完全自定义文件的存储结构，也不支持文件快捷方式的概念。这会导致秒传文件地址和源文件地址相同，可能导致隐私泄露等问题。（比如， A传送了img1，B也传送img1，B的img1复用了A的访问路径，在代码中，用户A上传的文件访问路径包含了A的id）。

## 扩展知识：分片上传和断点续传

对于大文件，还可以开启分片上传和断点续传，不需要自己开发，直接使用[对象存储的SDK](https://cloud.tencent.com/document/product/436/14112)就能完成。

>  分片上传的原理:
>
> 加入一个大文件有5MB，分片大小为1MB，那么该文件会被切分成5个块。客户端和服务端都会维持一个块计数。
>
> 如果客户端成功发送了一个块，则计数变为1/5， 服务端成功接收一个块，则块计数会变为1/5，直到完成所有块的接收。



# 图库优化三：图片加载优化

图片加载优化的目的是提升页面加载速度、减少带宽消耗，并改善用户体验。

优化技术：

> * 缩略图
> * 懒加载
> * CDN加速
> * 浏览器缓存

## 缩略图

问题：用户同时浏览许多图片时，直接加载原图，会造成流量浪费。

在查询图片列表时，并不需要查看到完整清晰的图像，可以展示缩略图，如果用户对某个图片感兴趣，进入详情页后展示完整图像。

解决方案：在上传图片时，同时生成一份小尺寸的缩略图。只有在用户进入详情页或下载时，才加载原图。

* 实现方案：
  * 本地图像处理类库
  * 第三方服务：腾讯云数据万象支持生成缩略图。

> 注意：并不是所有图片都要生成缩略图。如果上传的图片本身就很小，再为其生成缩略图就浪费空间了。此时可以就是用原图存储的地址替代缩略图地址。

## 懒加载

图片懒加载（Lazy Loading）是一种用于提升网页或应用程序性能的技术。其基本原理是，不在页面加载时一次性加载所有图片，而是在用户滚动页面到特定位置，即将要看到某张图片时，才开始加载这张图片。这种方式可以减少初始加载时间，节省带宽，并且减轻服务器负担。

适用场景： 包含大量图片的网页，如电子商务网站、图库或者社交媒体平台。

实现方法：

* 在`<img>`标签中添加`loading="lazy"`属性。简单，但对旧版浏览器（如IE）不兼容，而且不支持更复杂的懒加载需求(如动画或特殊事件触发）。
* 使用JS的InterSection Observer，这个API能够检测元素是否进入视口。实现原理如下:
  1. 将图片的真实src替换为一个占位属性(如data-src)。
  2. 使用Intersection Observer监听图片是否进入视口。
  3. 当图片进入视口时，将data-src的值赋给src，触发加载。
* 使用JS监听页面滚动事件实现，每次页面滚动，判断图片是否进入可视区域，如果是，则添加src属性。
* 使用现成的组件库或者类库，比如lazysized库。

在本项目中，由于使用了缩略图，就不需要用懒加载了。

> 扩展：
>
> 渐进加载：
>
> 当用户网络资源较差时，先预先加载一个低质量的占位资源，再在用户访问或等待期间逐步加载高分辨率的完整资源，加载完成后再替换掉占位资源。

## CDN加速

CDN，全称为Content Delivery Network（内容分发网络），是一种通过分布式服务器系统来传输服务内容的应用，旨在更高效地将数据分发给用户。

**CDN的作用：**

1. **加速访问速度**：通过将内容缓存到距离用户最近的服务器节点上，减少延迟时间。
2. **减轻源站压力**：大量的静态资源请求被CDN节点处理，减少了对源站服务器的压力。
3. **提升可用性**：即使某个地区的服务器出现问题，其他地区的服务器仍然可以提供服务，增强了系统的稳定性和可靠性。
4. **增强安全性**：一些CDN服务提供商还提供安全防护功能，如DDoS攻击防御等。

**CDN与COS的区别**：

CDN（内容分发网络）：偏重于响应用户获取资源的请求。能够对高频访问的文件进行访问加速，减轻源站压力。

腾讯云COS（对象存储）：如果文件存储容量需求大，且访问频率低，cos会更有性价比。

CDN的流量和请求单价通常低于对象存储，更加安全，可以保护源站地址不被泄露。

## 浏览器缓存

通过设置HTTP头信息（如Cache-Control），可以让用户将资源缓存在本地。当用户再次访问时，可以直接从本地加载资源。

所有缓存在设置时都需要考虑类似的事情：

1. 合理的过期时间：
   * 静态资源使用长期缓存。
   * 动态内容使用验证缓存，比如`Cache-Control:private, no-cache`表示缓存可被客户端存储，但每次使用前需要与服务器验证有效性。
   * 敏感内容禁用缓存，比如`Cache-control:no-store`。适用安全性较高的场景，比如登录页面，支付页面。
2. 要能够及时更新缓存。可以给图片的名称添加“版本号”。假如说，用户上传了图片aaa.png，然后对图片进行了编辑操作，如果名称仍是aaa.png，用户在访问时就会访问到缓存。

# 图库优化四：存储优化

## 数据沉降与冷热分离

* 数据沉降

一条数据往往在刚发布时具有一定的热度，但是随着时间推移，其热度会逐渐降低最后甚至消失。此时，便可以将这条热度消失的数据转储到成本更低的设备中。

> 热数据往往在上传后，短时间内被大量访问而热度升高，一段时间后热度逐渐降低或者不再需要被实时访问。您可以通过生命周期规则将30天前的数据转换为低频存储，进一步可以将60天前的数据转换为归档存储，这个过程称之为数据沉降。

* 冷热分层

数据的热度不同，有的被频繁访问，有的基本不被访问。将热度高的数据存储在访问速度快，成本高的设备中，将热度低的数据存储在访问速度慢，成本低的设备中。

---

数据沉降和冷热分层概念有点相似，数据沉降关注的是数据的生命周期，从热转冷，进而发生存储位置的迁移；冷热分离关注的是数据的分层。

## 清理策略

* 立即清理：在删除图片记录时，立即清理对象存储中，与之关联的图片文件，确保数据库记录与存储文件保持一致。

> 小技巧：可以使用异步的方法发起删除请求，并记录一些日志，避免删除失败的情况。在SpringBoot中，方法上打上@Async即代表该方法执行时，启用一个线程来执行。

* 手动清理: 由管理员来手动触发清理任务。可以筛选要清理的数据，按需选择需要清理的文件范围。

* 定期清理： 通过定时任务自动触发清理操作。可自定义清理规则。

* 惰性清理：清理任务不会主动执行，而是等待资源需求增加（存储空间不足）或触发特定操作才会清理。适合存储空间紧张但是清理任务优先级较低的场景。

实际开发中，以上几种清理策略常常组合使用。比如Redis的内存管理机制结合了定期清理和惰性清理策略。定期清理是通过后台定期扫描一部分键，如果键过期，则删除。惰性清理是，在访问键时，先判断改建是否过期，如果过期则删除。

## 扩展

1. 补充更多清理时机：在重新上传图片时，虽然那条图片记录不会删除，但其实之前的图片文件已经作废了，也可以出发清理逻辑。
2. 实现更多清理策略：比如用Spring Scheduler定时任务实现定时清理，编写一个接口供管理员手动清理，作为一种兜底策略。
3. 优化清理文件的代码，比如要删除多个文件，使用批量删除，代替for循环删除。
4. 为了清理原图，可以在数据库中保存原图的地址。



# 2025-05-24

# 第二阶段



# 空间模块



## 需求分析

1. 用户能够创建私人空间
2. 用户能够向私人空间中添加，修改，删除，查询图片（无需审核）
3. 用户能够管理自己的私人空间
4. 私人空间具有容量上限
5. 管理员能够修改用户私人空间属性

## 方案设计

* 库表设计

首先是，库表的五个固定字段：id， createTime, updateTime, editTime, isDelete。其次，空间名称(spaceName), 空间等级(spaceLevel), 空间已使用容量(spaceSizeUsed), 空间最大容量(spaceMaxSize), 空间已有图片数(spaceCount), 空间最大支持图片数(spaceMaxCount),空间创建者Id(userId)。

图片表需要添加一个新的列，spaceId，以标识该图片属于哪个空间。

```sql
-- 空间表
create table if not exists space
(
    id           bigint auto_increment comment 'id' primary key,
    spaceName         varchar(128)            default '私人空间'           not null comment '空间名称',
    spaceLevel tinyint      default 0           not   null comment '空间等级',
    spaceSizeUsed     bigint default 0                        not null comment '空间已使用容量',
    spaceMaxSize         bigint   1073741824    default               not  null comment '空间最大容量',
    userId       bigint                             not null comment '创建用户 id',
    createTime   datetime default CURRENT_TIMESTAMP not null comment '创建时间',
    editTime     datetime default CURRENT_TIMESTAMP not null comment '编辑时间',
    updateTime   datetime default CURRENT_TIMESTAMP not null on update CURRENT_TIMESTAMP comment '更新时间',
    isDelete     tinyint  default 0                 not null comment '是否删除',
    INDEX idx_userId (userId),                 -- 提升基于用户的查询性能
    INDEX idx_spaceName (spaceName), -- 提升基于空间名称的查询效率
    INDEX idx_spaceLevel (spaceLevel),         -- 提升基于空间级别的查询性能
) comment '空间' collate = utf8mb4_unicode_ci;

alter table picture
	add column spaceId bigint null comment '空间id (为空表示公共空间)';
```

* 流程设计

1. 用户能够创建私人空间: 用户至多创建一个私人空间（需要使用**编程式事务**，而不能简单地使用@Transactional注解，后面详细解释）
   1. 校验请求参数
   2. 判断用户是否创建过空间
      * 是， 拒绝请求
   3. 校验用户权限，如果是普通用户，则只能创建普通空间
   4. 设置好新建空间的相关属性，插入到数据库中
   5. 返回成功创建响应
2. 用户能够向私人空间中添加，修改，删除，查询图片（无需审核）
   * 添加：
     1. 校验请求参数
     2. 查询用户私人空间信息，如果存在，则获取空间id，否则操作失败
     3. 校验用户空间是否有剩余空间，如果没有，则抛出异常。
     4. 为添加的图片记录设置好空间id属性
     5. 执行添加图片操作
     6. 返回响应结果
   * 修改：
     1. 无需修改，复用公共空间修改逻辑
   * 删除：
     1. 校验请求参数
     2. 判断要删除的资源是否存在
     3. 若不存在，抛出异常；若存在，获取资源占用空间
     4. 修改该资源所在空间的容量，记录条数属性
     5. 删除资源记录
     6. 返回响应结果
   * 查询：
     1. 校验请求参数
     2. 判断用户是否查询自己私人空间的图片
        * 如果是， 查询用户的私人空间，获取私人空间id，判断是否与查询条件中的空间id一致
        * 如果不是，抛出无权限异常
     3. 获取查询条件，构造queryWrapper（）
     4. 查询，并返回结果
3. 用户能够管理自己的私人空间
   * 更新：（由于目前用户可修改的信息较少，主要是空间名称可供修改）
     1. 校验请求参数
     2. 从数据库中，查询空间记录
     3. 设置修改后的参数（注意，用户更新，需要设置editTime属性）
     4. 重新插入到数据库
     5. 返回结果
   * 删除：
     1. 这里无需校验请求参数，用户登录态从session获取
     2. 根据用户id查询用户空间
     3. 如果存在，则执行删除操作
     4. 从图片表中，删除所有该用户空间下的图片记录
     5. 返回响应结果
4. 管理员能够修改用户私人空间属性
   1. 校验请求参数（该接口上需要打上权限校验注解）
   2. 查询数据库判断要修改的私人空间是否存在
      * 不存在， 抛异常
   3. 设置要修改的参数，进行更新
   4. 返回结果

# 2025-05-27

# 图片功能扩展

* 图片搜索
  * 按照编辑时间搜索
  * 按照图片搜索（以图搜图）
  * 按照平均色调搜索
  * 按图片格式搜索
* 图片分享
  * 链接分享 
  * 扫码分享（前端生成）
* 图片批量管理
  * 批量修改信息
  * 批量重命名

## 图片批量管理

* 需求分析

  能够对图片的分类、标签进行批量修改。

  能够按照一定的规则为批量图片重命名。

* 方案设计

  **批量修改的优化点**：

  * 校验参数：在执行批量操作前，做好充足的参数校验工作，确保批量能够正常运行。
  * 查询优化：在查询数据库时，只选择需要的字段（比如查询picutre表， 只要id,spaceId)，减少数据库开销。
  * 事务：确保操作的原子性，如果有一条记录失败，则回滚这一批的操作。
  * 批量更新：使用Mybatis-plus提供的updateBatchById，而不是for循环更新。

  如果批量非常大，还可以采用，多线程，分批处理和并发编程。



# 2025-05-30

# AI图片编辑

得益于大模型能力的发展，可以利用多模态大模型的能力，直接对图片进行编辑操作。

调用阿里云百炼平台的api来增强现有功能。

## 异步调用

由于生成图片的操作往往会耗费时间，同步执行该操作，会导致用户过久的等待。所以采用异步调用的方式。

> https://bailian.console.aliyun.com/?tab=api#/api/?type=model&url=https%3A%2F%2Fhelp.aliyun.com%2Fdocument_detail%2F2796845.html&renderType=iframe
>
> 为了减少等待时间并且避免请求超时，服务采用异步方式提供。您需要发起两个请求：
>
> - **步骤1：创建任务获取任务ID**：首先发送一个请求创建扩图任务，该请求会返回任务ID。
> - **步骤2：根据任务ID查询结果**：使用上一步获得的任务ID，查询模型生成的结果。

由于任务ID至关重要，一旦丢失，就会导致无法获取任务结果。所以本地需要新建表来存储相关信息。

## 需求分析

用户能够上传图片ID或者图片url，来为该图片进行扩图。

## 方案设计

* 库表设计

```sql
# 首先，仍然是5个固定字段：id, createTime, editTime, updateTime, isDelete。然后，需要保存创建任务的相关信息，这些信息来源于API的响应结果，主要有request_id, task_id, task_status, code, message。另外，还需要记录是谁创建了这个任务，所以需要userId.

-- 任务表
create table if not exists task
(
    id            bigint auto_increment comment 'id' primary key,
    taskId        varchar(128)                                not null comment '任务id',
    requestId        varchar(128)                                null comment '请求唯一标识。可用于请求明细溯源和问题排查。',
    taskStatus        varchar(128)                                null comment '任务状态。',
    code     varchar(128)         null comment '请求失败的错误码。请求成功时不会返回此参数',
    message     varchar(128)         null comment '请求失败的消息。请求成功时不会返回此参数',
    userId        bigint                                 not null comment '创建用户 id',
    createTime    datetime     default CURRENT_TIMESTAMP not null comment '创建时间',
    editTime      datetime     default CURRENT_TIMESTAMP not null comment '编辑时间',
    updateTime    datetime     default CURRENT_TIMESTAMP not null on update CURRENT_TIMESTAMP comment '更新时间',
    isDelete      tinyint      default 0                 not null comment '是否删除',
    INDEX idx_userId (userId),        -- 提升基于用户的查询性能
    INDEX idx_taskStatus (taskStatus)  -- 提升基于任务状态的查询效率
) comment '任务' collate = utf8mb4_unicode_ci;
```

* 流程设计

用户创建任务：

1. 用户发送扩图请求
2. 校验用户是否登录以及是否有权限（目前只要用户登录都有权限）
3. 服务器发送http请求到API平台，获取创建任务响应结果。
4. 将相应结果保存到数据库中。
5. 如果成功创建任务，返回给用户task_id;如果失败，返回错误消息。

用户查询任务结果：

1. 用户将task_id发送到服务器
2. 服务器查询数据库，判断状态，如果为pending(任务排队中)或者Running(任务处理中)，则下一步；否则，直接返回给用户数据库结果。
3. 发送查询请求到api平台，获取最新结果
4. 判断和当前数据库的task_status是否一致，不一致，更新数据库后返回结果；一致，直接返回响应结果，对数据库不做更新。

# 2025-06-01

# 图库分析

## 需求分析

对于用户和管理员，都有获取图库整体信息的需求，以便于更好的了解自己的图库，影响后续决策（比如，升级空间，删除占用过多的图片类别等。）

用户需求：

1. 用户能够查询自己空间的空间占用量以及图片数量。
2. 用户能够根据分类查询自己空间下不同类别的图片的空间占用量和数量。
3. 用户能够根据不同的标签，统计各个标签下关联的图片数量
4. 用户能够统计不同空间占用范围内的图片数量。
5. 用户能够根据不同的时间尺度统计自己上传的图片数量。

管理员需求：

1. 管理员能够对全空间（私有+公共）或者公共空间进行分析。
   1. 统计空间的存储总占用以及资源总数量
2. 管理员能够查询空间使用量最多的前N个用户的空间信息。

## 方案设计

## 1. 分析类需求的实现流程：

1） 数据采集： 从数据源（比如Mysql数据库或者大数据仓库）获取原始数据。要提前明确涉及的表和字段，必要时采用分页查询处理大量数据。

2）数据预处理：对数据进行清洗、加工和格式化。 包括：过滤无效数据（比如逻辑删除或审核未通过）、解析复杂字段（比如JSON格式的tags），以及通过字段关联补充上下文信息。

3）数据计算：根据需求进行分组、聚合、排序等操作，进而计算关键指标。比如 计算空间各分类图片的占用比例、用户上传图片的趋势等。 根据场景调整计算方案，比如对于大数据量的计算，可以使用Spark等大数据计算组件做离线计算；而对于实时性要求较高的实时分析场景， 可以用Flink做流式处理。

4）数据存储（可选）：针对频繁查询的分析结果，可以将数据结果存储为单独的表或缓存，减少重复计算，提高查询效率。

5）数据接口设计：为前段提供统一接口，从而支持查询和展示。需要考虑到数据量较大导致前段渲染卡顿的情况，可以按需精简返回的字符串、分页查询等。

6）数据可视化：通过图表直观展示分析结果。

后续还可以根据用户的反馈持续优化分析逻辑、增加指标或者改进性能。

## 2. 抽取公共请求参数

从分析流程上来看，用户做出分析行为时，首先需要指出查询空间的范围。即是 查询全空间，公共空间或是私有空间。可以使用queryAll,queryPublic和SpaceId来标识这三个查询范围。

## 3. 具体需求流程

首先，需要预先定义好请求参数接受类，以及响应返回类。需要抽取出公共请求参数接收类，用来标识用户分析的空间范围，后续其他不同类别的分析请求，继承该类即可。

另外，需要抽取出公共权限校验逻辑，如果用户分析某一个私有空间，那么空间必须属于该用户或者该用户为管理员。如果用户分析全空间或公共空间，那么用户必须是管理员。

1. 用户能够查询自己空间的空间占用量以及图片数量。
   1. 用户传递要查询的空间id
   2. 校验参数
   3. 校验权限
   4. 查询空间表，获取相关信息
   5. 封装返回结果
2. 用户能够根据分类查询自己空间下不同类别的图片的空间占用量和数量。（管理员也可用于不同范围的空间）
   1. 用户传递需要查询的范围
   2. 校验参数非空
   3. 校验权限
   4. 构造查询条件，根据类别进行分组，然后进行聚合。**需要注意，只查需要的字段**
   5. 根据查询结果进行分析计算，封装为返回结果
3. 用户能够根据标签，统计不同标签下的图片数量。（管理员也可用于不同范围的空间）
   1. 用户传递需要查询的范围
   2. 校验参数非空
   3. 校验权限
   4. 构造查询条件，根据查询范围，查询出所有的tags字段到内存中。
   5. 将tags字段转为json得到字段列表，然后利用扁平化，获取所有图片的标签，再根据各个标签出现的次数进行统计。
   6. 构造返回的VO对象，返回结果。

4. 用户能够统计不同空间占用范围内的图片数量。
   1. 用户传递需要查询的范围
   2. 校验参数非空
   3. 校验权限
   4. 构造查询条件，根据查询范围，查询出所有的tags字段到内存中。
   5. 使用java8 stream api来进行统计操作
   6. 返回结果

5. 用户能够根据不同的时间尺度统计自己上传的图片数量。
   1. 用户传递需要查询的范围
   2. 校验参数非空
   3. 校验权限
   4. 构造查询条件，根据用户传递的时间维度来分组统计数据。需要利用到msyql的时间函数
   5. 使用java8 stream api来进行统计操作
   6. 返回结果


管理员：

略。	

# 扩展（TODO）

1. 新增分析需求，
   按照空间级别对空间进行分类统计，分析不同级别空间的使用情况。
2. 新增分析需求，
   管理员可以对系统内图片的审核状态进行分类统计，还可以按时间维度分析图片审核量的变化趋势。
3. 新增分析需求，管理员可以按时间统计用户的登录次数、图片上传量和活跃度的变化趋势，帮助管理员识别高活跃用户，对用户进行分层管理。
4. 用户行为分析支持同环比分析，在同一个图表中展示两条折线(比如一条是上周的，一条是这周的)。

# 2025-06-02

# 第三阶段

# 团队空间







