# 2025.5.13

初始化项目

# 2025.5.14

进行项目的前期工作。规范化。

抽象通用请求体。比如：删除数据请求， 分页查询请求。

抽象通用响应体。 编写BaseResponse类，封装响应体，包含：响应码， 数据， 消息， 描述。

构建全局异常处理器。

抽象通用业务异常类。

抽像通用错误响应码。

--------

# 第一阶段

完成用户管理以及图片管理模块。

* 阶段流程：
  1. 需求分析
  2. 方案设计
  3. 后端开发
  4. 前端开发

## 需求分析

1. 用户能够注册，登录，退出登录。
2. 用户能够修改个人信息
3. 用户具有管理员和普通用户这两个角色，不同角色具有不同权限。
4. 用户管理：仅管理员可用， 能够创建用户，修改用户，查询用户，搜索用户。
5. 获取当前登录用户

## 方案设计

* 库表设计

首先，用户表需要有 固定的五个字段（企业开发常见规范） ： id（用户标识）， editTime（用户编辑时间）, createTime（本条记录创建时间）, updateTime（本条记录更新时间，这个和editTime的区别是，即使是管理员直接修改数据库，这个时间也要更新）, isDelete（逻辑删除）。

然后是与用户体验相关的字段：用户昵称， 用户账号， 用户密码，用户头像，用户简介， 用户角色。

```sql
-- 用户表
create table if not exists user
(
    id           bigint auto_increment comment 'id' primary key,
    userAccount  varchar(256)                           not null comment '账号',
    userPassword varchar(512)                           not null comment '密码',
    userName     varchar(256)                           null comment '用户昵称',
    userAvatar   varchar(1024)                          null comment '用户头像',
    userProfile  varchar(512)                           null comment '用户简介',
    userRole     varchar(256) default 'user'            not null comment '用户角色：user/admin',
    editTime     datetime     default CURRENT_TIMESTAMP not null comment '编辑时间',
    createTime   datetime     default CURRENT_TIMESTAMP not null comment '创建时间',
    updateTime   datetime     default CURRENT_TIMESTAMP not null on update CURRENT_TIMESTAMP comment '更新时间',
    isDelete     tinyint      default 0                 not null comment '是否删除',
    UNIQUE KEY uk_userAccount (userAccount),
    INDEX idx_userName (userName)
    ) comment '用户' collate = utf8mb4_unicode_ci;
    
-- 用户账号添加了唯一索引， 用户昵称添加了普通索引，能够加速以名称为条件时的查询
```

* 流程设计

用户注册：

需要一个UserRegisterRequest请求封装类， 用于接收用户的输入参数，主要包含用户账户， 用户密码， 确认密码。

1. 接收到请用户注册请求封装类参数后，先校验其是否为空，若为空则抛出BusinessException异常。
2. 调用UserService服务，进行用户注册。
   1. 校验用户账户，用户密码是否符合要求。用户账户长度要在5-20之间，用户密码长度要在6-10之间，用户密码要和确认密码相同。
   2. 在userService服务中，先查询该用户账户是否存在，若不存在，则继续下一步；否则，抛出异常。
   3. 插入用户数据，返回插入结果。
3. 在Controller层，需要以BaseResponse<>的统一响应体形式返回结果给用户。

> **tip**:
>
> 由于后端使用Long类型来标识用户id，而前端接收时，会自动将id解析为number类型，number的是双精度浮点类型，其取值范围没有long类型大，所以，当我们的id由mybatis自己生成时，会导致long数值过大，前端解析时会出现精度溢出。
>
> 对于需要使用超大整数的场景，服务端一律使用String字符串类型返回，禁止使用Long类型。
>
> ```java
> package com.tlm.storecollab.config;
> 
> import com.fasterxml.jackson.databind.ObjectMapper;
> import com.fasterxml.jackson.databind.module.SimpleModule;
> import com.fasterxml.jackson.databind.ser.std.ToStringSerializer;
> import org.springframework.boot.jackson.JsonComponent;
> import org.springframework.context.annotation.Bean;
> import org.springframework.http.converter.json.Jackson2ObjectMapperBuilder;
> 
> /**
>  * Spring MVC Json 配置
>  */
> @JsonComponent
> public class JsonConfig {
> 
>     /**
>      * 添加 Long 转 json 精度丢失的配置
>      */
>     @Bean
>     public ObjectMapper jacksonObjectMapper(Jackson2ObjectMapperBuilder builder) {
>         ObjectMapper objectMapper = builder.createXmlMapper(false).build();
>         SimpleModule module = new SimpleModule();
>         module.addSerializer(Long.class, ToStringSerializer.instance);
>         module.addSerializer(Long.TYPE, ToStringSerializer.instance);
>         objectMapper.registerModule(module);
>         return objectMapper;
>     }
> }
> ```

用户登录：

需要一个UserLoginRequest请求封装类， 用于接收用户的输入参数，主要包含用户账户， 用户密码。使用Lombok注解为其生成get和set方法。

1. 接收到请用户登录请求封装类参数后，先校验其是否为空，若为空则抛出BusinessException异常。
2. 调用UserService服务，进行用户登录。
   1. 查询数据库，判断用户是否存在。不存在，抛出异常；若存在，继续下一步。
   2. 校验数据库中的密码和当前用户输入的密码加密后是否相等。如果相等，登录成功，将用户信息存入session中，否则，返回用户登录失败信息。
3. 返回用户登录结果信息。

获取当前登录用户：

首先需要要给LoginUserVO试图封装类，需要对User对象进行脱敏，屏蔽一些敏感字段。使用Lombok注解为其生成get，set方法，并添加serailversionId字段。

1. 从Session中获取当前用户的登录态。判断用户是否登录，如果获取不到，则表示用户未登录，抛出未登录异常。
2. 根据获取到的登录态，取出用户的id，从数据库中查询该用户，得到User对象。
3. 将得到的User对象通过BeanUtils工具进行属性复制到LoginUserVO类中并返回给Controller层。
4. 在Controller层返回LoginUserVO。







