# 2025.5.13

初始化项目

# 2025.5.14

进行项目的前期工作。规范化。

抽象通用请求体。比如：删除数据请求， 分页查询请求。

抽象通用响应体。 编写BaseResponse类，封装响应体，包含：响应码， 数据， 消息， 描述。

构建全局异常处理器。

抽象通用业务异常类。

抽像通用错误响应码。

--------

# 第一阶段

完成用户管理以及图片管理模块。

* 阶段流程：
  1. 需求分析
  2. 方案设计
  3. 后端开发
  4. 前端开发

## 需求分析

1. 用户能够注册，登录，退出登录。
2. 用户能够修改个人信息
3. 用户具有管理员和普通用户这两个角色，不同角色具有不同权限。
4. 用户管理：仅管理员可用， 能够创建用户，修改用户，查询用户，搜索用户。
5. 获取当前登录用户

## 方案设计

* 库表设计

首先，用户表需要有 固定的五个字段（企业开发常见规范） ： id（用户标识）， editTime（用户编辑时间）, createTime（本条记录创建时间）, updateTime（本条记录更新时间，这个和editTime的区别是，即使是管理员直接修改数据库，这个时间也要更新）, isDelete（逻辑删除）。

然后是与用户体验相关的字段：用户昵称， 用户账号， 用户密码，用户头像，用户简介， 用户角色。

```sql
-- 用户表
create table if not exists user
(
    id           bigint auto_increment comment 'id' primary key,
    userAccount  varchar(256)                           not null comment '账号',
    userPassword varchar(512)                           not null comment '密码',
    userName     varchar(256)                           null comment '用户昵称',
    userAvatar   varchar(1024)                          null comment '用户头像',
    userProfile  varchar(512)                           null comment '用户简介',
    userRole     varchar(256) default 'user'            not null comment '用户角色：user/admin',
    editTime     datetime     default CURRENT_TIMESTAMP not null comment '编辑时间',
    createTime   datetime     default CURRENT_TIMESTAMP not null comment '创建时间',
    updateTime   datetime     default CURRENT_TIMESTAMP not null on update CURRENT_TIMESTAMP comment '更新时间',
    isDelete     tinyint      default 0                 not null comment '是否删除',
    UNIQUE KEY uk_userAccount (userAccount),
    INDEX idx_userName (userName)
    ) comment '用户' collate = utf8mb4_unicode_ci;
    
-- 用户账号添加了唯一索引， 用户昵称添加了普通索引，能够加速以名称为条件时的查询
```

* 流程设计

用户注册：

需要一个UserRegisterRequest请求封装类， 用于接收用户的输入参数，主要包含用户账户， 用户密码， 确认密码。

1. 接收到请用户注册请求封装类参数后，先校验其是否为空，若为空则抛出BusinessException异常。
2. 调用UserService服务，进行用户注册。
   1. 校验用户账户，用户密码是否符合要求。用户账户长度要在5-20之间，用户密码长度要在6-10之间，用户密码要和确认密码相同。
   2. 在userService服务中，先查询该用户账户是否存在，若不存在，则继续下一步；否则，抛出异常。
   3. 插入用户数据，返回插入结果。
3. 在Controller层，需要以BaseResponse<>的统一响应体形式返回结果给用户。

> **tip**:
>
> 由于后端使用Long类型来标识用户id，而前端接收时，会自动将id解析为number类型，number的是双精度浮点类型，其取值范围没有long类型大，所以，当我们的id由mybatis自己生成时，会导致long数值过大，前端解析时会出现精度溢出。
>
> 对于需要使用超大整数的场景，服务端一律使用String字符串类型返回，禁止使用Long类型。
>
> ```java
> package com.tlm.storecollab.config;
> 
> import com.fasterxml.jackson.databind.ObjectMapper;
> import com.fasterxml.jackson.databind.module.SimpleModule;
> import com.fasterxml.jackson.databind.ser.std.ToStringSerializer;
> import org.springframework.boot.jackson.JsonComponent;
> import org.springframework.context.annotation.Bean;
> import org.springframework.http.converter.json.Jackson2ObjectMapperBuilder;
> 
> /**
>  * Spring MVC Json 配置
>  */
> @JsonComponent
> public class JsonConfig {
> 
>     /**
>      * 添加 Long 转 json 精度丢失的配置
>      */
>     @Bean
>     public ObjectMapper jacksonObjectMapper(Jackson2ObjectMapperBuilder builder) {
>         ObjectMapper objectMapper = builder.createXmlMapper(false).build();
>         SimpleModule module = new SimpleModule();
>         module.addSerializer(Long.class, ToStringSerializer.instance);
>         module.addSerializer(Long.TYPE, ToStringSerializer.instance);
>         objectMapper.registerModule(module);
>         return objectMapper;
>     }
> }
> ```

用户登录：

需要一个UserLoginRequest请求封装类， 用于接收用户的输入参数，主要包含用户账户， 用户密码。使用Lombok注解为其生成get和set方法。

1. 接收到请用户登录请求封装类参数后，先校验其是否为空，若为空则抛出BusinessException异常。
2. 调用UserService服务，进行用户登录。
   1. 查询数据库，判断用户是否存在。不存在，抛出异常；若存在，继续下一步。
   2. 校验数据库中的密码和当前用户输入的密码加密后是否相等。如果相等，登录成功，将用户信息存入session中，否则，返回用户登录失败信息。
3. 返回用户登录结果信息。

获取当前登录用户：

首先需要要给LoginUserVO试图封装类，需要对User对象进行脱敏，屏蔽一些敏感字段。使用Lombok注解为其生成get，set方法，并添加serailversionId字段。

1. 从Session中获取当前用户的登录态。判断用户是否登录，如果获取不到，则表示用户未登录，抛出未登录异常。
2. 根据获取到的登录态，取出用户的id，从数据库中查询该用户，得到User对象。
3. 将得到的User对象通过BeanUtils工具进行属性复制到LoginUserVO类中并返回给Controller层。
4. 在Controller层返回LoginUserVO。

用户权限校验管理：**自定义注解进行权限校验**

利用AOP，对需要校验用户权限的方法，在执行方法前进行权限校验。

先定义好注解AuthCheck,里面包含一个mustRole属性，默认值为空，代表不需要任何权限。

再定义一个切面，在切面中再定义校验权限的切点。

所以，进行AOP切面编程，需要定义两个个东西：切面，切点。而由于使用注解来标识需要进行权限校验的方法，所以还需要定义注解。

1. 定义注解:

   ```java
   package com.tlm.storecollab.annotation;
   
   import java.lang.annotation.ElementType;
   import java.lang.annotation.Retention;
   import java.lang.annotation.RetentionPolicy;
   import java.lang.annotation.Target;
   
   @Target(ElementType.METHOD)
   @Retention(RetentionPolicy.RUNTIME)
   public @interface AuthCheck {
   
       String mustRole() default "";
   }
   
   ```

2. 定义切面和切点

   ```java
   @Aspect
   @Component
   public class AuthInterceptor {
   
       @Around("@annotation(authCheck)")
       public Object doIntercept(ProceedingJoinPoint joinPoint, AuthCheck authCheck) throws Throwable {
           String role = authCheck.mustRole();
           UserRoleEnum userRole = UserRoleEnum.getValueByValue(role);
   
           // 如果不需要权限，则直接执行
           if (userRole == null){
               return joinPoint.proceed();
           }
   
           // 获取当前用户所具有的权限
           RequestAttributes requestAttributes = RequestContextHolder.currentRequestAttributes();
           HttpServletRequest request = ((ServletRequestAttributes) requestAttributes).getRequest();
           Object attribute = request.getSession().getAttribute(UserConstant.USER_LOGIN_STATE);
           ThrowUtils.throwIf(ObjectUtil.isNull(attribute), ErrorCode.NOT_LOGIN);
           User loginUser = (User) attribute;
           String loginUserRole = loginUser.getUserRole();
           UserRoleEnum loginUserRoleEnum = UserRoleEnum.getValueByValue(loginUserRole);
   
           // 如果用户没有任何权限，则抛出异常
           ThrowUtils.throwIf(ObjectUtil.isNull(loginUserRoleEnum), ErrorCode.NO_AUTH);
   
           // 如果权限需要为 管理员 才能执行， 而用户又不是管理员
           if (UserRoleEnum.ADMIN.equals(userRole) && !UserRoleEnum.ADMIN.equals(loginUserRoleEnum)){
               throw new BusinessException(ErrorCode.NO_AUTH);
           }
   
           return joinPoint.proceed();
       }
   }
   
   ```

### 用户管理

用户管理功能具体可以拆分为:

* [管理员] 创建用户
* [管理员]根据id删除用户
* [管理员] 更新用户
* [管理员] 分页查询用户列表（需要脱敏）
* [管理员] 根据id获取用户（未脱敏）
* 根据id获取用户（脱敏）



# 2025.05.15

# 图片模块

## 需求分析

管理员：

1. 上传和创建图片。（这里的理解：上传图片是指将图片存储到对象服务中，创建图片是指在数据库中创建一条图片记录）
2. 管理图片， 包括查询图片，修改图片，删除。
3. 能够根据图片属性进行分页查询。

普通用户：

1. 查看与搜索图片列表（主页）
2. 查看图片详情（详情页）
3. 图片下载

具体分析每个需求：

1. 上传和创建图片：仅管理员可用，支持选择本地图片上传，同时指定图片的相关信息，如名称，简介，标签，分类等。系统会自动解析图片的基础信息（如宽高和格式等），便于检索。
2. 图片管理：管理员可以对图库内的图片资源进行删除，修改，查询。
3. 查看搜索图片列表：用户在主页可以按关键字搜索图片，支持按分类、标签筛选条件分页查看图片列表。
4. 查看图片详情：点击某张图片后，可以进入详情页，查看图片的具体信息。
5. 图片下载：用户在详情页可以点击下载图片按钮，将图片保存到本地。

## 方案设计

* 库表设计 ： 主要是图片表， 需要有固定的五个字段(id, editTime, udpateTime, createTime, isDelete)。另外还有，url, name,introduction,category,tags,picSize,picWidth,picHeight,picScale,picFormat,userId。
  **哪些字段上需要加索引**：经常被作为条件查询，分组的字段，最好加上索引。

  ```java
  -- 图片表
  create table if not exists picture
  (
      id           bigint auto_increment comment 'id' primary key,
      url          varchar(512)                       not null comment '图片 url',
      name         varchar(128)                       not null comment '图片名称',
      introduction varchar(512)                       null comment '简介',
      category     varchar(64)                        null comment '分类',
      tags         varchar(512)                       null comment '标签（JSON 数组）',
      picSize      bigint                             null comment '图片体积',
      picWidth     int                                null comment '图片宽度',
      picHeight    int                                null comment '图片高度',
      picScale     double                             null comment '图片宽高比例',
      picFormat    varchar(32)                        null comment '图片格式',
      userId       bigint                             not null comment '创建用户 id',
      createTime   datetime default CURRENT_TIMESTAMP not null comment '创建时间',
      editTime     datetime default CURRENT_TIMESTAMP not null comment '编辑时间',
      updateTime   datetime default CURRENT_TIMESTAMP not null on update CURRENT_TIMESTAMP comment '更新时间',
      isDelete     tinyint  default 0                 not null comment '是否删除',
      INDEX idx_name (name),                 -- 提升基于图片名称的查询性能
      INDEX idx_introduction (introduction), -- 用于模糊搜索图片简介
      INDEX idx_category (category),         -- 提升基于分类的查询性能
      INDEX idx_tags (tags),                 -- 提升基于标签的查询性能
      INDEX idx_userId (userId)              -- 提升基于用户 ID 的查询性能
  ) comment '图片' collate = utf8mb4_unicode_ci;
  ```

* 如何存储图片？最简单的方法，将图片存储在本地服务器上。但是这种方法具有很多劣势。

  1. 不具扩展性。本地服务器存储容量有限，扩充麻烦。
  2. 不具安全性。本地服务器可能存在漏洞，恶意用户通过代码可能越权访问到隐私信息。
  3. 不具管理性。本地存储只能存储文件本身，没有提供额外的管理服务。腾讯云对象存储，还提供了数据万象等功能，能够分析数据。
  4. 不具可迁移性。当本地服务器需要迁移时，图片数据也需要跟着迁移，增加迁移成本。

* 存储图片业务流程。

  1. 传统方法，先上传再提交数据：用户在页面点击上传图片后，就会图片存储到云服务对象存储中并生成url，此时数据库中并不会生成一条记录。待用户填写其他信息并提交后，才会在数据库生成记录。
  2. 上传图片时就生成记录：用户上传图片时，直接在数据库生成记录。随后，用户填写其他信息，相当于更新数据库中已有的记录。

  方案1的特点是：流程简单。但是一旦用户上传文件后没有提交其他信息，文件就会残留在对象存储中，造成资源浪费。方案二的特点是：用户的操作和数据记录一致，能够溯源，还能够对用户上传图片做一些限制。

* 如何解析图片属性？
  根据需求，要获取地图片信息有：宽，高，宽高比，大小，格式，名称。
  主流获取图片属性的方式有两种：

  1. 后端直接处理图片。java库ImageIO,python库Pillow，OpenCV等。
  2. 通过第三方云存储服务或图像处理API直接提取图片元数据。

* 如何下载图片？
  下载图片有三种方式。
  1. 服务器从对象存储中下载图片到本地，用户从服务器上下载。
  2. 服务器从对象存储中获取流返回给前端，用户从流中读取数据。这种方法不需要服务器下载图片。
  3. 服务器生成临时密钥给前端，前端拿临时密钥去对象存储中下载。（企业常用，但繁琐）。





